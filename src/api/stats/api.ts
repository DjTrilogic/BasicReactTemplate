/**
 * Fut Bot
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Amount
 */
export interface Amount {
    /**
     * 
     * @type {string}
     * @memberof Amount
     */
    total?: string;
    /**
     * 
     * @type {string}
     * @memberof Amount
     */
    currency?: string;
}

/**
 * 
 * @export
 * @interface CaptchaOutcomeViewModel
 */
export interface CaptchaOutcomeViewModel {
    /**
     * 
     * @type {number}
     * @memberof CaptchaOutcomeViewModel
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CaptchaOutcomeViewModel
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CaptchaOutcomeViewModel
     */
    errorMessage?: string;
    /**
     * 
     * @type {Date}
     * @memberof CaptchaOutcomeViewModel
     */
    date?: Date;
}

/**
 * 
 * @export
 * @interface ExecutionAmount
 */
export interface ExecutionAmount {
    /**
     * 
     * @type {string}
     * @memberof ExecutionAmount
     */
    total?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionAmount
     */
    currency?: string;
    /**
     * 
     * @type {ExecutionDetails}
     * @memberof ExecutionAmount
     */
    details?: ExecutionDetails;
}

/**
 * 
 * @export
 * @interface ExecutionBillingAddress
 */
export interface ExecutionBillingAddress {
    /**
     * 
     * @type {string}
     * @memberof ExecutionBillingAddress
     */
    line1?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionBillingAddress
     */
    line2?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionBillingAddress
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionBillingAddress
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionBillingAddress
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionBillingAddress
     */
    countryCode?: string;
}

/**
 * 
 * @export
 * @interface ExecutionDetails
 */
export interface ExecutionDetails {
    /**
     * 
     * @type {string}
     * @memberof ExecutionDetails
     */
    subtotal?: string;
}

/**
 * 
 * @export
 * @interface ExecutionItemList
 */
export interface ExecutionItemList {
    /**
     * 
     * @type {ExecutionShippingAddress1}
     * @memberof ExecutionItemList
     */
    shippingAddress?: ExecutionShippingAddress1;
}

/**
 * 
 * @export
 * @interface ExecutionLink
 */
export interface ExecutionLink {
    /**
     * 
     * @type {string}
     * @memberof ExecutionLink
     */
    href?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionLink
     */
    rel?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionLink
     */
    method?: string;
}

/**
 * 
 * @export
 * @interface ExecutionPayee
 */
export interface ExecutionPayee {
    /**
     * 
     * @type {string}
     * @memberof ExecutionPayee
     */
    merchantId?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionPayee
     */
    email?: string;
}

/**
 * 
 * @export
 * @interface ExecutionPayer
 */
export interface ExecutionPayer {
    /**
     * 
     * @type {string}
     * @memberof ExecutionPayer
     */
    paymentMethod?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionPayer
     */
    status?: string;
    /**
     * 
     * @type {ExecutionPayerInfo}
     * @memberof ExecutionPayer
     */
    payerInfo?: ExecutionPayerInfo;
}

/**
 * 
 * @export
 * @interface ExecutionPayerInfo
 */
export interface ExecutionPayerInfo {
    /**
     * 
     * @type {string}
     * @memberof ExecutionPayerInfo
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionPayerInfo
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionPayerInfo
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionPayerInfo
     */
    payerId?: string;
    /**
     * 
     * @type {ExecutionShippingAddress}
     * @memberof ExecutionPayerInfo
     */
    shippingAddress?: ExecutionShippingAddress;
    /**
     * 
     * @type {string}
     * @memberof ExecutionPayerInfo
     */
    countryCode?: string;
    /**
     * 
     * @type {ExecutionBillingAddress}
     * @memberof ExecutionPayerInfo
     */
    billingAddress?: ExecutionBillingAddress;
}

/**
 * 
 * @export
 * @interface ExecutionRelatedResources
 */
export interface ExecutionRelatedResources {
    /**
     * 
     * @type {Sale}
     * @memberof ExecutionRelatedResources
     */
    sale?: Sale;
}

/**
 * 
 * @export
 * @interface ExecutionShippingAddress
 */
export interface ExecutionShippingAddress {
    /**
     * 
     * @type {string}
     * @memberof ExecutionShippingAddress
     */
    recipientName?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionShippingAddress
     */
    line1?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionShippingAddress
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionShippingAddress
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionShippingAddress
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionShippingAddress
     */
    countryCode?: string;
}

/**
 * 
 * @export
 * @interface ExecutionShippingAddress1
 */
export interface ExecutionShippingAddress1 {
    /**
     * 
     * @type {string}
     * @memberof ExecutionShippingAddress1
     */
    recipientName?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionShippingAddress1
     */
    line1?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionShippingAddress1
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionShippingAddress1
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionShippingAddress1
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionShippingAddress1
     */
    countryCode?: string;
}

/**
 * 
 * @export
 * @interface ExecutionTransaction
 */
export interface ExecutionTransaction {
    /**
     * 
     * @type {ExecutionAmount}
     * @memberof ExecutionTransaction
     */
    amount?: ExecutionAmount;
    /**
     * 
     * @type {ExecutionPayee}
     * @memberof ExecutionTransaction
     */
    payee?: ExecutionPayee;
    /**
     * 
     * @type {ExecutionItemList}
     * @memberof ExecutionTransaction
     */
    itemList?: ExecutionItemList;
    /**
     * 
     * @type {Array<ExecutionRelatedResources>}
     * @memberof ExecutionTransaction
     */
    relatedResources?: Array<ExecutionRelatedResources>;
}

/**
 * 
 * @export
 * @interface ExecutionTransactionFee
 */
export interface ExecutionTransactionFee {
    /**
     * 
     * @type {string}
     * @memberof ExecutionTransactionFee
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionTransactionFee
     */
    currency?: string;
}

/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    href?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    rel?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    method?: string;
}

/**
 * 
 * @export
 * @interface ModelPackage
 */
export interface ModelPackage {
    /**
     * 
     * @type {number}
     * @memberof ModelPackage
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelPackage
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelPackage
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelPackage
     */
    octofutiumsAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelPackage
     */
    price?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelPackage
     */
    isActive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelPackage
     */
    isLimited?: boolean;
}

/**
 * 
 * @export
 * @interface Payer
 */
export interface Payer {
    /**
     * 
     * @type {string}
     * @memberof Payer
     */
    paymentMethod?: string;
}

/**
 * 
 * @export
 * @interface PaymentCreationResponse
 */
export interface PaymentCreationResponse {
    /**
     * 
     * @type {string}
     * @memberof PaymentCreationResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentCreationResponse
     */
    intent?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentCreationResponse
     */
    state?: string;
    /**
     * 
     * @type {Payer}
     * @memberof PaymentCreationResponse
     */
    payer?: Payer;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof PaymentCreationResponse
     */
    transactions?: Array<Transaction>;
    /**
     * 
     * @type {Date}
     * @memberof PaymentCreationResponse
     */
    createTime?: Date;
    /**
     * 
     * @type {Array<Link>}
     * @memberof PaymentCreationResponse
     */
    links?: Array<Link>;
}

/**
 * 
 * @export
 * @interface PaymentExecutionResponse
 */
export interface PaymentExecutionResponse {
    /**
     * 
     * @type {string}
     * @memberof PaymentExecutionResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentExecutionResponse
     */
    intent?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentExecutionResponse
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentExecutionResponse
     */
    cart?: string;
    /**
     * 
     * @type {ExecutionPayer}
     * @memberof PaymentExecutionResponse
     */
    payer?: ExecutionPayer;
    /**
     * 
     * @type {Array<ExecutionTransaction>}
     * @memberof PaymentExecutionResponse
     */
    transactions?: Array<ExecutionTransaction>;
    /**
     * 
     * @type {Date}
     * @memberof PaymentExecutionResponse
     */
    createTime?: Date;
    /**
     * 
     * @type {Array<ExecutionLink>}
     * @memberof PaymentExecutionResponse
     */
    links?: Array<ExecutionLink>;
}

/**
 * 
 * @export
 * @interface PlayerCardViewModel
 */
export interface PlayerCardViewModel {
    /**
     * 
     * @type {number}
     * @memberof PlayerCardViewModel
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerCardViewModel
     */
    commonName?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerCardViewModel
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerCardViewModel
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerCardViewModel
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PlayerCardViewModel
     */
    leagueId?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerCardViewModel
     */
    nationId?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerCardViewModel
     */
    clubId?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerCardViewModel
     */
    clubImageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerCardViewModel
     */
    nationImageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerCardViewModel
     */
    imageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerCardViewModel
     */
    position?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerCardViewModel
     */
    playStyle?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerCardViewModel
     */
    isIcon?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PlayerCardViewModel
     */
    quality?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerCardViewModel
     */
    isSpecialType?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PlayerCardViewModel
     */
    baseId?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerCardViewModel
     */
    rating?: number;
}

/**
 * 
 * @export
 * @interface PlayerHistoryComboViewModel
 */
export interface PlayerHistoryComboViewModel {
    /**
     * 
     * @type {Array<PlayerHistoryEntryViewModel>}
     * @memberof PlayerHistoryComboViewModel
     */
    updates?: Array<PlayerHistoryEntryViewModel>;
    /**
     * 
     * @type {Array<PlayerHistoryEntryViewModel>}
     * @memberof PlayerHistoryComboViewModel
     */
    sells?: Array<PlayerHistoryEntryViewModel>;
    /**
     * 
     * @type {Array<PlayerHistoryEntryViewModel>}
     * @memberof PlayerHistoryComboViewModel
     */
    buys?: Array<PlayerHistoryEntryViewModel>;
}

/**
 * 
 * @export
 * @interface PlayerHistoryEntryViewModel
 */
export interface PlayerHistoryEntryViewModel {
    /**
     * 
     * @type {number}
     * @memberof PlayerHistoryEntryViewModel
     */
    price?: number;
    /**
     * 
     * @type {Date}
     * @memberof PlayerHistoryEntryViewModel
     */
    date?: Date;
}

/**
 * 
 * @export
 * @interface PricedPlayerViewModel
 */
export interface PricedPlayerViewModel {
    /**
     * 
     * @type {PlayerCardViewModel}
     * @memberof PricedPlayerViewModel
     */
    playerCard?: PlayerCardViewModel;
    /**
     * 
     * @type {number}
     * @memberof PricedPlayerViewModel
     */
    forceBuyPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof PricedPlayerViewModel
     */
    forceSellPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof PricedPlayerViewModel
     */
    maxNumberOfSameCard?: number;
    /**
     * 
     * @type {number}
     * @memberof PricedPlayerViewModel
     */
    buyWhenPriceIsBelowThan?: number;
    /**
     * 
     * @type {number}
     * @memberof PricedPlayerViewModel
     */
    sellWhenPriceIsHigherThan?: number;
    /**
     * 
     * @type {number}
     * @memberof PricedPlayerViewModel
     */
    updateDelay?: number;
}

/**
 * 
 * @export
 * @interface RefererViewModel
 */
export interface RefererViewModel {
    /**
     * 
     * @type {string}
     * @memberof RefererViewModel
     */
    username?: string;
    /**
     * 
     * @type {number}
     * @memberof RefererViewModel
     */
    referalsCount?: number;
}

/**
 * 
 * @export
 * @interface Sale
 */
export interface Sale {
    /**
     * 
     * @type {string}
     * @memberof Sale
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Sale
     */
    state?: string;
    /**
     * 
     * @type {ExecutionAmount}
     * @memberof Sale
     */
    amount?: ExecutionAmount;
    /**
     * 
     * @type {string}
     * @memberof Sale
     */
    paymentMode?: string;
    /**
     * 
     * @type {string}
     * @memberof Sale
     */
    protectionEligibility?: string;
    /**
     * 
     * @type {string}
     * @memberof Sale
     */
    protectionEligibilityType?: string;
    /**
     * 
     * @type {ExecutionTransactionFee}
     * @memberof Sale
     */
    transactionFee?: ExecutionTransactionFee;
    /**
     * 
     * @type {string}
     * @memberof Sale
     */
    parentPayment?: string;
    /**
     * 
     * @type {Date}
     * @memberof Sale
     */
    createTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Sale
     */
    updateTime?: Date;
    /**
     * 
     * @type {Array<ExecutionLink>}
     * @memberof Sale
     */
    links?: Array<ExecutionLink>;
}

/**
 * 
 * @export
 * @interface SaleAggregationViewModel
 */
export interface SaleAggregationViewModel {
    /**
     * 
     * @type {number}
     * @memberof SaleAggregationViewModel
     */
    count?: number;
}

/**
 * 
 * @export
 * @interface SaleViewModel
 */
export interface SaleViewModel {
    /**
     * 
     * @type {PlayerCardViewModel}
     * @memberof SaleViewModel
     */
    playerCard?: PlayerCardViewModel;
    /**
     * 
     * @type {number}
     * @memberof SaleViewModel
     */
    profit?: number;
    /**
     * 
     * @type {number}
     * @memberof SaleViewModel
     */
    buyPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof SaleViewModel
     */
    sellPrice?: number;
    /**
     * 
     * @type {Date}
     * @memberof SaleViewModel
     */
    date?: Date;
    /**
     * 
     * @type {string}
     * @memberof SaleViewModel
     */
    botUsername?: string;
}

/**
 * 
 * @export
 * @interface SerializedEvent
 */
export interface SerializedEvent {
    /**
     * 
     * @type {string}
     * @memberof SerializedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SerializedEvent
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof SerializedEvent
     */
    eventType?: string;
    /**
     * 
     * @type {Date}
     * @memberof SerializedEvent
     */
    date?: Date;
}

/**
 * 
 * @export
 * @interface ShopListViewModel
 */
export interface ShopListViewModel {
    /**
     * 
     * @type {number}
     * @memberof ShopListViewModel
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ShopListViewModel
     */
    platform?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopListViewModel
     */
    name?: string;
    /**
     * 
     * @type {Array<PricedPlayerViewModel>}
     * @memberof ShopListViewModel
     */
    searches?: Array<PricedPlayerViewModel>;
}

/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {Amount}
     * @memberof Transaction
     */
    amount?: Amount;
    /**
     * 
     * @type {Array<any>}
     * @memberof Transaction
     */
    relatedResources?: Array<any>;
}


/**
 * CardsApi - fetch parameter creator
 * @export
 */
export const CardsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} term 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsByTerm(term: string, options: any = {}): FetchArgs {
            // verify required parameter 'term' is not null or undefined
            if (term === null || term === undefined) {
                throw new RequiredError('term', 'Required parameter term was null or undefined when calling getCardsByTerm.');
            }
            const localVarPath = `/api/Cards/term={term}`
                .replace(`{${"term"}}`, encodeURIComponent(String(term)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardsApi - functional programming interface
 * @export
 */
export const CardsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} term 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsByTerm(term: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PlayerCardViewModel>> {
            const localVarFetchArgs = CardsApiFetchParamCreator(configuration).getCardsByTerm(term, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CardsApi - factory interface
 * @export
 */
export const CardsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} term 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsByTerm(term: string, options?: any) {
            return CardsApiFp(configuration).getCardsByTerm(term, options)(fetch, basePath);
        },
    };
};

/**
 * CardsApi - object-oriented interface
 * @export
 * @class CardsApi
 * @extends {BaseAPI}
 */
export class CardsApi extends BaseAPI {
    /**
     * 
     * @param {string} term 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public getCardsByTerm(term: string, options?: any) {
        return CardsApiFp(this.configuration).getCardsByTerm(term, options)(this.fetch, this.basePath);
    }

}

/**
 * HistoryApi - fetch parameter creator
 * @export
 */
export const HistoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} botId 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCaptchaOutcomes(botId: string, page: number, options: any = {}): FetchArgs {
            // verify required parameter 'botId' is not null or undefined
            if (botId === null || botId === undefined) {
                throw new RequiredError('botId', 'Required parameter botId was null or undefined when calling getCaptchaOutcomes.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page', 'Required parameter page was null or undefined when calling getCaptchaOutcomes.');
            }
            const localVarPath = `/api/History/{botId}/captchas/{page}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} platform 
         * @param {number} resourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComboPlayerHistory(platform: number, resourceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'platform' is not null or undefined
            if (platform === null || platform === undefined) {
                throw new RequiredError('platform', 'Required parameter platform was null or undefined when calling getComboPlayerHistory.');
            }
            // verify required parameter 'resourceId' is not null or undefined
            if (resourceId === null || resourceId === undefined) {
                throw new RequiredError('resourceId', 'Required parameter resourceId was null or undefined when calling getComboPlayerHistory.');
            }
            const localVarPath = `/api/History/playerExtended/{platform}/{resourceId}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} botId 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistory(botId: string, page: number, options: any = {}): FetchArgs {
            // verify required parameter 'botId' is not null or undefined
            if (botId === null || botId === undefined) {
                throw new RequiredError('botId', 'Required parameter botId was null or undefined when calling getHistory.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page', 'Required parameter page was null or undefined when calling getHistory.');
            }
            const localVarPath = `/api/History/{botId}/{page}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} platform 
         * @param {number} resourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerHistory(platform: number, resourceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'platform' is not null or undefined
            if (platform === null || platform === undefined) {
                throw new RequiredError('platform', 'Required parameter platform was null or undefined when calling getPlayerHistory.');
            }
            // verify required parameter 'resourceId' is not null or undefined
            if (resourceId === null || resourceId === undefined) {
                throw new RequiredError('resourceId', 'Required parameter resourceId was null or undefined when calling getPlayerHistory.');
            }
            const localVarPath = `/api/History/player/{platform}/{resourceId}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HistoryApi - functional programming interface
 * @export
 */
export const HistoryApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} botId 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCaptchaOutcomes(botId: string, page: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CaptchaOutcomeViewModel>> {
            const localVarFetchArgs = HistoryApiFetchParamCreator(configuration).getCaptchaOutcomes(botId, page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} platform 
         * @param {number} resourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComboPlayerHistory(platform: number, resourceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerHistoryComboViewModel> {
            const localVarFetchArgs = HistoryApiFetchParamCreator(configuration).getComboPlayerHistory(platform, resourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} botId 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistory(botId: string, page: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SaleViewModel>> {
            const localVarFetchArgs = HistoryApiFetchParamCreator(configuration).getHistory(botId, page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} platform 
         * @param {number} resourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerHistory(platform: number, resourceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PlayerHistoryEntryViewModel>> {
            const localVarFetchArgs = HistoryApiFetchParamCreator(configuration).getPlayerHistory(platform, resourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HistoryApi - factory interface
 * @export
 */
export const HistoryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} botId 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCaptchaOutcomes(botId: string, page: number, options?: any) {
            return HistoryApiFp(configuration).getCaptchaOutcomes(botId, page, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} platform 
         * @param {number} resourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComboPlayerHistory(platform: number, resourceId: number, options?: any) {
            return HistoryApiFp(configuration).getComboPlayerHistory(platform, resourceId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} botId 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistory(botId: string, page: number, options?: any) {
            return HistoryApiFp(configuration).getHistory(botId, page, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} platform 
         * @param {number} resourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerHistory(platform: number, resourceId: number, options?: any) {
            return HistoryApiFp(configuration).getPlayerHistory(platform, resourceId, options)(fetch, basePath);
        },
    };
};

/**
 * HistoryApi - object-oriented interface
 * @export
 * @class HistoryApi
 * @extends {BaseAPI}
 */
export class HistoryApi extends BaseAPI {
    /**
     * 
     * @param {string} botId 
     * @param {number} page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getCaptchaOutcomes(botId: string, page: number, options?: any) {
        return HistoryApiFp(this.configuration).getCaptchaOutcomes(botId, page, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} platform 
     * @param {number} resourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getComboPlayerHistory(platform: number, resourceId: number, options?: any) {
        return HistoryApiFp(this.configuration).getComboPlayerHistory(platform, resourceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} botId 
     * @param {number} page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getHistory(botId: string, page: number, options?: any) {
        return HistoryApiFp(this.configuration).getHistory(botId, page, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} platform 
     * @param {number} resourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getPlayerHistory(platform: number, resourceId: number, options?: any) {
        return HistoryApiFp(this.configuration).getPlayerHistory(platform, resourceId, options)(this.fetch, this.basePath);
    }

}

/**
 * LogsApi - fetch parameter creator
 * @export
 */
export const LogsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} botId 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogs(botId: string, page: number, options: any = {}): FetchArgs {
            // verify required parameter 'botId' is not null or undefined
            if (botId === null || botId === undefined) {
                throw new RequiredError('botId', 'Required parameter botId was null or undefined when calling getLogs.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page', 'Required parameter page was null or undefined when calling getLogs.');
            }
            const localVarPath = `/api/Logs/{botId}/{page}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellingApiLogs(page: number, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page', 'Required parameter page was null or undefined when calling getSellingApiLogs.');
            }
            const localVarPath = `/api/Logs/selling-api/{page}`
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} botId 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogs(botId: string, page: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SerializedEvent>> {
            const localVarFetchArgs = LogsApiFetchParamCreator(configuration).getLogs(botId, page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellingApiLogs(page: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SerializedEvent>> {
            const localVarFetchArgs = LogsApiFetchParamCreator(configuration).getSellingApiLogs(page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LogsApi - factory interface
 * @export
 */
export const LogsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} botId 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogs(botId: string, page: number, options?: any) {
            return LogsApiFp(configuration).getLogs(botId, page, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSellingApiLogs(page: number, options?: any) {
            return LogsApiFp(configuration).getSellingApiLogs(page, options)(fetch, basePath);
        },
    };
};

/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
export class LogsApi extends BaseAPI {
    /**
     * 
     * @param {string} botId 
     * @param {number} page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public getLogs(botId: string, page: number, options?: any) {
        return LogsApiFp(this.configuration).getLogs(botId, page, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public getSellingApiLogs(page: number, options?: any) {
        return LogsApiFp(this.configuration).getSellingApiLogs(page, options)(this.fetch, this.basePath);
    }

}

/**
 * PaymentApi - fetch parameter creator
 * @export
 */
export const PaymentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [itemId] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(itemId?: number, accountId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/Payment/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (itemId !== undefined) {
                localVarFormParams.set('ItemId', itemId as any);
            }

            if (accountId !== undefined) {
                localVarFormParams.set('AccountId', accountId as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [paymentId] 
         * @param {string} [payerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        execute(paymentId?: string, payerId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/Payment/execute`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (paymentId !== undefined) {
                localVarFormParams.set('PaymentId', paymentId as any);
            }

            if (payerId !== undefined) {
                localVarFormParams.set('PayerId', payerId as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackages(options: any = {}): FetchArgs {
            const localVarPath = `/api/Payment/packages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemainingOctofutiums(options: any = {}): FetchArgs {
            const localVarPath = `/api/Payment/Currency`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [itemId] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(itemId?: number, accountId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentCreationResponse> {
            const localVarFetchArgs = PaymentApiFetchParamCreator(configuration).create(itemId, accountId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [paymentId] 
         * @param {string} [payerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        execute(paymentId?: string, payerId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentExecutionResponse> {
            const localVarFetchArgs = PaymentApiFetchParamCreator(configuration).execute(paymentId, payerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackages(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ModelPackage>> {
            const localVarFetchArgs = PaymentApiFetchParamCreator(configuration).getPackages(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemainingOctofutiums(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PaymentApiFetchParamCreator(configuration).getRemainingOctofutiums(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [itemId] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(itemId?: number, accountId?: string, options?: any) {
            return PaymentApiFp(configuration).create(itemId, accountId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [paymentId] 
         * @param {string} [payerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        execute(paymentId?: string, payerId?: string, options?: any) {
            return PaymentApiFp(configuration).execute(paymentId, payerId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackages(options?: any) {
            return PaymentApiFp(configuration).getPackages(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemainingOctofutiums(options?: any) {
            return PaymentApiFp(configuration).getRemainingOctofutiums(options)(fetch, basePath);
        },
    };
};

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI {
    /**
     * 
     * @param {number} [itemId] 
     * @param {string} [accountId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public create(itemId?: number, accountId?: string, options?: any) {
        return PaymentApiFp(this.configuration).create(itemId, accountId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [paymentId] 
     * @param {string} [payerId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public execute(paymentId?: string, payerId?: string, options?: any) {
        return PaymentApiFp(this.configuration).execute(paymentId, payerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPackages(options?: any) {
        return PaymentApiFp(this.configuration).getPackages(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getRemainingOctofutiums(options?: any) {
        return PaymentApiFp(this.configuration).getRemainingOctofutiums(options)(this.fetch, this.basePath);
    }

}

/**
 * ShopListsApi - fetch parameter creator
 * @export
 */
export const ShopListsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} listId 
         * @param {PricedPlayerViewModel} [pricedPlayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPlayer(listId: number, pricedPlayer?: PricedPlayerViewModel, options: any = {}): FetchArgs {
            // verify required parameter 'listId' is not null or undefined
            if (listId === null || listId === undefined) {
                throw new RequiredError('listId', 'Required parameter listId was null or undefined when calling addPlayer.');
            }
            const localVarPath = `/api/ShopLists/{listId}/addPlayer`
                .replace(`{${"listId"}}`, encodeURIComponent(String(listId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PricedPlayerViewModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(pricedPlayer || {}) : (pricedPlayer || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShopListViewModel} [shopList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewShopList(shopList?: ShopListViewModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/ShopLists`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ShopListViewModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(shopList || {}) : (shopList || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} listId 
         * @param {PricedPlayerViewModel} [pricedPlayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlayer(listId: number, pricedPlayer?: PricedPlayerViewModel, options: any = {}): FetchArgs {
            // verify required parameter 'listId' is not null or undefined
            if (listId === null || listId === undefined) {
                throw new RequiredError('listId', 'Required parameter listId was null or undefined when calling deletePlayer.');
            }
            const localVarPath = `/api/ShopLists/{listId}/deletePlayer`
                .replace(`{${"listId"}}`, encodeURIComponent(String(listId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PricedPlayerViewModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(pricedPlayer || {}) : (pricedPlayer || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShopListViewModel} [shopList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShopList(shopList?: ShopListViewModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/ShopLists`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ShopListViewModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(shopList || {}) : (shopList || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} listId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopList(listId: number, options: any = {}): FetchArgs {
            // verify required parameter 'listId' is not null or undefined
            if (listId === null || listId === undefined) {
                throw new RequiredError('listId', 'Required parameter listId was null or undefined when calling getShopList.');
            }
            const localVarPath = `/api/ShopLists/{listId}`
                .replace(`{${"listId"}}`, encodeURIComponent(String(listId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopLists(options: any = {}): FetchArgs {
            const localVarPath = `/api/ShopLists`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} listId 
         * @param {PricedPlayerViewModel} [pricedPlayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer(listId: number, pricedPlayer?: PricedPlayerViewModel, options: any = {}): FetchArgs {
            // verify required parameter 'listId' is not null or undefined
            if (listId === null || listId === undefined) {
                throw new RequiredError('listId', 'Required parameter listId was null or undefined when calling updatePlayer.');
            }
            const localVarPath = `/api/ShopLists/{listId}/updatePlayer`
                .replace(`{${"listId"}}`, encodeURIComponent(String(listId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PricedPlayerViewModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(pricedPlayer || {}) : (pricedPlayer || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShopListViewModel} [shopList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShopList(shopList?: ShopListViewModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/ShopLists`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ShopListViewModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(shopList || {}) : (shopList || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShopListsApi - functional programming interface
 * @export
 */
export const ShopListsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} listId 
         * @param {PricedPlayerViewModel} [pricedPlayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPlayer(listId: number, pricedPlayer?: PricedPlayerViewModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ShopListsApiFetchParamCreator(configuration).addPlayer(listId, pricedPlayer, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ShopListViewModel} [shopList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewShopList(shopList?: ShopListViewModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ShopListsApiFetchParamCreator(configuration).createNewShopList(shopList, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} listId 
         * @param {PricedPlayerViewModel} [pricedPlayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlayer(listId: number, pricedPlayer?: PricedPlayerViewModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ShopListsApiFetchParamCreator(configuration).deletePlayer(listId, pricedPlayer, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ShopListViewModel} [shopList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShopList(shopList?: ShopListViewModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ShopListsApiFetchParamCreator(configuration).deleteShopList(shopList, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} listId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopList(listId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShopListViewModel> {
            const localVarFetchArgs = ShopListsApiFetchParamCreator(configuration).getShopList(listId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopLists(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ShopListViewModel>> {
            const localVarFetchArgs = ShopListsApiFetchParamCreator(configuration).getShopLists(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} listId 
         * @param {PricedPlayerViewModel} [pricedPlayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer(listId: number, pricedPlayer?: PricedPlayerViewModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ShopListsApiFetchParamCreator(configuration).updatePlayer(listId, pricedPlayer, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ShopListViewModel} [shopList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShopList(shopList?: ShopListViewModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ShopListsApiFetchParamCreator(configuration).updateShopList(shopList, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ShopListsApi - factory interface
 * @export
 */
export const ShopListsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} listId 
         * @param {PricedPlayerViewModel} [pricedPlayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPlayer(listId: number, pricedPlayer?: PricedPlayerViewModel, options?: any) {
            return ShopListsApiFp(configuration).addPlayer(listId, pricedPlayer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ShopListViewModel} [shopList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewShopList(shopList?: ShopListViewModel, options?: any) {
            return ShopListsApiFp(configuration).createNewShopList(shopList, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} listId 
         * @param {PricedPlayerViewModel} [pricedPlayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlayer(listId: number, pricedPlayer?: PricedPlayerViewModel, options?: any) {
            return ShopListsApiFp(configuration).deletePlayer(listId, pricedPlayer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ShopListViewModel} [shopList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShopList(shopList?: ShopListViewModel, options?: any) {
            return ShopListsApiFp(configuration).deleteShopList(shopList, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} listId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopList(listId: number, options?: any) {
            return ShopListsApiFp(configuration).getShopList(listId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopLists(options?: any) {
            return ShopListsApiFp(configuration).getShopLists(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} listId 
         * @param {PricedPlayerViewModel} [pricedPlayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer(listId: number, pricedPlayer?: PricedPlayerViewModel, options?: any) {
            return ShopListsApiFp(configuration).updatePlayer(listId, pricedPlayer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ShopListViewModel} [shopList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShopList(shopList?: ShopListViewModel, options?: any) {
            return ShopListsApiFp(configuration).updateShopList(shopList, options)(fetch, basePath);
        },
    };
};

/**
 * ShopListsApi - object-oriented interface
 * @export
 * @class ShopListsApi
 * @extends {BaseAPI}
 */
export class ShopListsApi extends BaseAPI {
    /**
     * 
     * @param {number} listId 
     * @param {PricedPlayerViewModel} [pricedPlayer] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopListsApi
     */
    public addPlayer(listId: number, pricedPlayer?: PricedPlayerViewModel, options?: any) {
        return ShopListsApiFp(this.configuration).addPlayer(listId, pricedPlayer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ShopListViewModel} [shopList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopListsApi
     */
    public createNewShopList(shopList?: ShopListViewModel, options?: any) {
        return ShopListsApiFp(this.configuration).createNewShopList(shopList, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} listId 
     * @param {PricedPlayerViewModel} [pricedPlayer] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopListsApi
     */
    public deletePlayer(listId: number, pricedPlayer?: PricedPlayerViewModel, options?: any) {
        return ShopListsApiFp(this.configuration).deletePlayer(listId, pricedPlayer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ShopListViewModel} [shopList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopListsApi
     */
    public deleteShopList(shopList?: ShopListViewModel, options?: any) {
        return ShopListsApiFp(this.configuration).deleteShopList(shopList, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} listId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopListsApi
     */
    public getShopList(listId: number, options?: any) {
        return ShopListsApiFp(this.configuration).getShopList(listId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopListsApi
     */
    public getShopLists(options?: any) {
        return ShopListsApiFp(this.configuration).getShopLists(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} listId 
     * @param {PricedPlayerViewModel} [pricedPlayer] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopListsApi
     */
    public updatePlayer(listId: number, pricedPlayer?: PricedPlayerViewModel, options?: any) {
        return ShopListsApiFp(this.configuration).updatePlayer(listId, pricedPlayer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ShopListViewModel} [shopList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopListsApi
     */
    public updateShopList(shopList?: ShopListViewModel, options?: any) {
        return ShopListsApiFp(this.configuration).updateShopList(shopList, options)(this.fetch, this.basePath);
    }

}

/**
 * StatisticsApi - fetch parameter creator
 * @export
 */
export const StatisticsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bestDealEver(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/BestDealEver`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bestReferers(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/BestReferers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captchasOfTheDay(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/CaptchasOfTheDay`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealOfTheDay(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/DealOfTheDay`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsCountOfTheDay(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/DealsCountOfTheDay`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastSevenDayProfits(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/LastSevenDayProfits`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastSevenDaySales(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/LastSevenDaySales`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastThirtyDayProfits(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/LastThirtyDayProfits`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastThirtyDaySales(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/LastThirtyDaySales`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mostProfitableDay(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/MostProfitableDay`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mostProfitablePlayer(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/MostProfitablePlayer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCountOfTheDay(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/SalesCountOfTheDay`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalCaptchas(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/TotalCaptchas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalDealsCount(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/TotalDealsCount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalMadeCoins(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/TotalMadeCoins`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalSalesCount(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/TotalSalesCount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalSoldCoins(options: any = {}): FetchArgs {
            const localVarPath = `/api/Statistics/TotalSoldCoins`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatisticsApi - functional programming interface
 * @export
 */
export const StatisticsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bestDealEver(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SaleViewModel>> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).bestDealEver(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bestReferers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RefererViewModel>> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).bestReferers(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captchasOfTheDay(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SaleAggregationViewModel> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).captchasOfTheDay(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealOfTheDay(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SaleViewModel>> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).dealOfTheDay(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsCountOfTheDay(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SaleAggregationViewModel> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).dealsCountOfTheDay(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastSevenDayProfits(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SaleViewModel>> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).lastSevenDayProfits(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastSevenDaySales(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SaleViewModel>> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).lastSevenDaySales(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastThirtyDayProfits(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SaleViewModel>> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).lastThirtyDayProfits(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastThirtyDaySales(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SaleViewModel>> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).lastThirtyDaySales(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mostProfitableDay(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SaleViewModel> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).mostProfitableDay(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mostProfitablePlayer(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SaleViewModel>> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).mostProfitablePlayer(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCountOfTheDay(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SaleAggregationViewModel> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).salesCountOfTheDay(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalCaptchas(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SaleAggregationViewModel> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).totalCaptchas(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalDealsCount(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SaleAggregationViewModel> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).totalDealsCount(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalMadeCoins(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SaleAggregationViewModel> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).totalMadeCoins(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalSalesCount(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SaleAggregationViewModel> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).totalSalesCount(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalSoldCoins(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SaleAggregationViewModel> {
            const localVarFetchArgs = StatisticsApiFetchParamCreator(configuration).totalSoldCoins(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StatisticsApi - factory interface
 * @export
 */
export const StatisticsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bestDealEver(options?: any) {
            return StatisticsApiFp(configuration).bestDealEver(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bestReferers(options?: any) {
            return StatisticsApiFp(configuration).bestReferers(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captchasOfTheDay(options?: any) {
            return StatisticsApiFp(configuration).captchasOfTheDay(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealOfTheDay(options?: any) {
            return StatisticsApiFp(configuration).dealOfTheDay(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsCountOfTheDay(options?: any) {
            return StatisticsApiFp(configuration).dealsCountOfTheDay(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastSevenDayProfits(options?: any) {
            return StatisticsApiFp(configuration).lastSevenDayProfits(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastSevenDaySales(options?: any) {
            return StatisticsApiFp(configuration).lastSevenDaySales(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastThirtyDayProfits(options?: any) {
            return StatisticsApiFp(configuration).lastThirtyDayProfits(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastThirtyDaySales(options?: any) {
            return StatisticsApiFp(configuration).lastThirtyDaySales(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mostProfitableDay(options?: any) {
            return StatisticsApiFp(configuration).mostProfitableDay(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mostProfitablePlayer(options?: any) {
            return StatisticsApiFp(configuration).mostProfitablePlayer(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salesCountOfTheDay(options?: any) {
            return StatisticsApiFp(configuration).salesCountOfTheDay(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalCaptchas(options?: any) {
            return StatisticsApiFp(configuration).totalCaptchas(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalDealsCount(options?: any) {
            return StatisticsApiFp(configuration).totalDealsCount(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalMadeCoins(options?: any) {
            return StatisticsApiFp(configuration).totalMadeCoins(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalSalesCount(options?: any) {
            return StatisticsApiFp(configuration).totalSalesCount(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalSoldCoins(options?: any) {
            return StatisticsApiFp(configuration).totalSoldCoins(options)(fetch, basePath);
        },
    };
};

/**
 * StatisticsApi - object-oriented interface
 * @export
 * @class StatisticsApi
 * @extends {BaseAPI}
 */
export class StatisticsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public bestDealEver(options?: any) {
        return StatisticsApiFp(this.configuration).bestDealEver(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public bestReferers(options?: any) {
        return StatisticsApiFp(this.configuration).bestReferers(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public captchasOfTheDay(options?: any) {
        return StatisticsApiFp(this.configuration).captchasOfTheDay(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public dealOfTheDay(options?: any) {
        return StatisticsApiFp(this.configuration).dealOfTheDay(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public dealsCountOfTheDay(options?: any) {
        return StatisticsApiFp(this.configuration).dealsCountOfTheDay(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public lastSevenDayProfits(options?: any) {
        return StatisticsApiFp(this.configuration).lastSevenDayProfits(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public lastSevenDaySales(options?: any) {
        return StatisticsApiFp(this.configuration).lastSevenDaySales(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public lastThirtyDayProfits(options?: any) {
        return StatisticsApiFp(this.configuration).lastThirtyDayProfits(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public lastThirtyDaySales(options?: any) {
        return StatisticsApiFp(this.configuration).lastThirtyDaySales(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public mostProfitableDay(options?: any) {
        return StatisticsApiFp(this.configuration).mostProfitableDay(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public mostProfitablePlayer(options?: any) {
        return StatisticsApiFp(this.configuration).mostProfitablePlayer(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public salesCountOfTheDay(options?: any) {
        return StatisticsApiFp(this.configuration).salesCountOfTheDay(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public totalCaptchas(options?: any) {
        return StatisticsApiFp(this.configuration).totalCaptchas(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public totalDealsCount(options?: any) {
        return StatisticsApiFp(this.configuration).totalDealsCount(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public totalMadeCoins(options?: any) {
        return StatisticsApiFp(this.configuration).totalMadeCoins(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public totalSalesCount(options?: any) {
        return StatisticsApiFp(this.configuration).totalSalesCount(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public totalSoldCoins(options?: any) {
        return StatisticsApiFp(this.configuration).totalSoldCoins(options)(this.fetch, this.basePath);
    }

}

